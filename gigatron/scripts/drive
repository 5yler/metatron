#!/usr/bin/env python

##
# drive
# Python script for reactive driveing based on laser scan
# 
# @author  Syler Wagner  <syler@mit.edu>
#
# @date 2015-09-21   syler   creation
# @date 2016-09-17   syler   added inverted laser handling
##

from __future__ import division

import rospy
from std_msgs.msg import String   # for switching Jetson/RC mode
import sys, select, termios, tty

from matplotlib import pyplot as plt
import matplotlib.patches as mpatches
import numpy as np
import math
from sensor_msgs.msg import LaserScan   # for switching Jetson/RC mode
from gigatron.msg import Drive   # for sending controls

from laser_geometry import LaserProjection # for getting and using PointCloud from LaserScan
from sensor_msgs.msg import PointCloud2 
import sensor_msgs.point_cloud2 as pc2

import tf   # for laser transform

follow_syler = False


fast_dist = 5   #Assumes with 5m of clearance ahead we can go as fast as possible

inf = float('nan')

# wrap angle to interval [-pi, pi]
def wrap_angle(angle):
    while angle > math.pi:
        angle -= 2*math.pi
    while angle < -math.pi:
        angle += 2*math.pi
    # sanity check
    assert angle > -math.pi and angle < math.pi
    return angle

# get sign of a number
def sign(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    elif x == 0:
        return 0
    else: # this covers NaN values
        return x

class Points():
    
    def __init__(self, point_list):
        if debug:
            print point_list
        self.angles = point_list[0]
        self.ranges = point_list[1]
        self.intensities = point_list[2]
        
    def num_points(self):
        print str(len(self.ranges))+" valid points"
        return len(self.ranges)

class Driver():

    def __init__(self):
        
        # control publisher
        print "Init'ing Publisher"
        self._pub = rospy.Publisher('/command/drive', Drive, queue_size=5)

        # scan subscriber
        print "Init'ing Subscriber"
        rospy.Subscriber('/scan_rp', LaserScan, self.callback)

        # get some parameters
        self._car_name = rospy.get_param("car/name")
        self._wheelbase_width = rospy.get_param("car/wheelbase_width")
        if rospy.has_param("car/wheel_diameter"):
            self._wheel_radius = rospy.get_param("car/wheel_diameter") / 2.0
        else:
            self._wheel_radius = rospy.get_param("car/wheel_radius")
        self._gear_ratio = rospy.get_param("car/gear_ratio")
        self._steering_angle_range = rospy.get_param("car/steering_angle_range")
        self._max_motor_rpm  = rospy.get_param("car/max_motor_rpm")

        print "Got parameters!"

        self._rpm_to_vel = (2 * math.pi * self._wheel_radius) / 60.0

        self._abs_max_steering_angle = 0.5 * self._steering_angle_range
        self._v_max = self._max_motor_rpm * self._rpm_to_vel * self._gear_ratio

        if rospy.has_param("~v_max"):
            self._v_max = rospy.get_param("~v_max")
            rospy.logerr("SETTING MAX AUTO VELOCITY TO %4.2f m/s", self._v_max)

        self._v_faster = self._v_max
        self._v_forward = 0.5 * self._v_max
        self._v_slowest = 0.25 * self._v_max

        self._got_laser_parameters = False

        self._laser_yaw = 0
        # self._listener = tf.TransformListener()
        # if rospy.has_param("laser_yaw"):
        #     self._laser_yaw = rospy.get_param("laser_yaw")
        # else:
        #     self._laser_yaw = 0
        self._inverted_laser = rospy.get_param("~inverted_laser")
        if self._inverted_laser:
            self._laser_yaw = math.pi

        rospy.logerr("LASER YAW OFFSET IS %4.2f RADIANS", self._laser_yaw)

        rospy.spin()

    # laser scan callback method
    def callback(self, scan):

        if not self._got_laser_parameters:
            self.initialize_laser_parameters(scan)

        ranges = scan.ranges
        intensities = scan.intensities
        control = Drive()
     
        # if self.ahead_clear(scan): #if clear, go fast!
        #     control.angle = 0.0
        #     control.vel_left = self._v_max
        #     control.vel_right = self._v_max
        # else: #drive normally
        drive_angle = self.steer(ranges, intensities)
        v = self.throttle(drive_angle)
        v_left, v_right = self.split_throttle(drive_angle, v)
        # drive_angle, v_left, v_right = proportional_throttle(steer_angle, ranges, intensities)

        if abs(drive_angle) > self._abs_max_steering_angle:
            drive_angle = drive_angle * (self._abs_max_steering_angle / abs(drive_angle))

        # set velocity commands
        control.angle = drive_angle  # driving angle 
        control.vel_left = max(v_left, 0)  # left wheel velocity
        control.vel_right = max(v_right, 0) # right wheel velocity

        rospy.logwarn("angle: %4.1f rad  V_l: %4.1f m/s  V_r: %4.1f m/s", control.angle, control.vel_left, control.vel_right)
        self._pub.publish(control)

    def initialize_laser_parameters(self, scan):

        self._angle_min = scan.angle_min
        self._angle_max = scan.angle_max
        self._angle_increment = scan.angle_increment
        self._range_min = scan.range_min
        self._range_max = scan.range_max
        # try: # try to look up transform between base_link and laser_link
        #     (trans, rot) = listener.lookupTransform('base_link', 'laser_link' rospy.Time(0))
        #     (roll, pitch, yaw) = tf.transformations.euler_from_quaternion(rot)
        #     self._laser_yaw += yaw
        # except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException), e:
        #     continue
        rospy.logwarn("Laser yaw offset: %4.2f radians", self._laser_yaw)

        self._got_laser_parameters = True

    # generate an array with the scan angles associated with sequential points in a laser scan
    def generate_scan_angles(self, angle_min, angle_max, angle_increment, yaw_offset=0):
        n_points = int(round((angle_max - angle_min + angle_increment)/angle_increment))
        angles = []
        for i in xrange(n_points):
            angle = wrap_angle(angle_min + i*angle_increment + yaw_offset)
            angles.append(angle)
        return angles


    # helper functions
    def point_ok(self, point):
        angle, r, intensity = point[0], point[1], point[2]

        if math.isnan(r): # check for inf
            return False
        if r < 0:
            return False
        elif intensity <= 0.0: # this might not be necessary
            return False
        elif r < self._range_min or r > self._range_max: 
            return False
        else:
            return True


    def narrow_fov(self, points, yaw_min, yaw_max):
        # return points with yaw in specified range
        #narrow = [p for p in zip(points[0], points[1], points[2]) if yaw_min < p[1] < yaw_max]

        #TODO won't this mess up if it has enough invalid points by offsetting by their angles?
        #I would expect to need to insert some placeholder point at min or max range, or 
        #somehow otherwise indicate that their spot has unknown value, but maybe since they 
        #all have an associated yaw value this is unnecessary?

        # return self.narrow_fov(points, yaw_min + (self._angle_max - self._angle_min), yaw_max + (self._angle_max - self._angle_min))

        narrow = [p for p in zip(points[0], points[1], points[2]) if yaw_min < p[0] < yaw_max and self.point_ok(p)]
        #$ removed angle filtering because we're just using an angle filtered scan now
        # narrow = [p for p in zip(points[0], points[1], points[2]) if self.point_ok(p)]
        return [list(n) for n in zip(*narrow)]

    def generate_narrow_fov_points(self, ranges, intensities, yaw_min=-math.pi/2, yaw_max=math.pi/2):

        angles = self.generate_scan_angles(self._angle_min, self._angle_max, self._angle_increment, self._laser_yaw)

        points = [angles, ranges, intensities]
        rospy.loginfo("len(points): %d", len(points))
        return self.narrow_fov(points, yaw_min, yaw_max)

    def polar_integrate(self, narrow):
        integral = 0;
        dirintegral = 0;
        for p in zip(narrow[0], narrow[1], narrow[2]):
            yaw = p[0]
            r = p[1]
            
            dirintegral += sign(yaw) * (1/r) * math.cos(yaw)
            integral += (1/r) * math.cos(yaw)
            #print r, yaw
        rospy.logerr("integral %4.1f, dirintegral %4.1f, dirintegral/integral %4.1f", integral, dirintegral, dirintegral/integral) 

        return dirintegral/integral

    def steer(self, ranges, intensities, yaw_min=-math.pi/2, yaw_max=math.pi/2):
        narrow = self.generate_narrow_fov_points(ranges, intensities, yaw_min, yaw_max)
        if len(narrow) !=0 and len(narrow[0]) != 0:
           drive_angle = self.polar_integrate(narrow)
        else:
            drive_angle = 0 
        return drive_angle

    def throttle(self, steer_angle):
        v = self._v_forward * (self._abs_max_steering_angle - abs(steer_angle)) / self._abs_max_steering_angle
        v = max(v, self._v_slowest) # so it doesn't stop at the extremes of turning range
        return v

    def split_throttle(self, steer_angle, v):
        # v = control_speed
        omega = (v * math.tan(steer_angle)) / self._wheelbase_width

        # TODO: test on Gigatron and see if it's actually worth using
        if self._car_name == "Kilotron":
            k_split = 0.25
        else:
            k_split = 1

        v_left = v - k_split * (omega / self._wheelbase_width)   # left wheel velocity
        v_right = v + k_split * (omega / self._wheelbase_width)   # right wheel velocity
        return v_left, v_right

    def proportional_throttle(self, steer_angle, ranges, intensities):
        v = throttle(steer_angle)
        points_ahead = self.generate_narrow_fov_points(ranges, intensities, (steer_angle - math.pi/8), (steer_angle + math.pi/8))
        ranges_ahead = []
        rospy.logwarn("proportional_throttle v: %4.1f", v)
        for p in zip(points_ahead[0], points_ahead[1], points_ahead[2]):
            ranges_ahead.append(p[0])

        if (len(ranges_ahead) > 0):
            min_dist = min(ranges_ahead)
            if (min_dist < 5):
                angle = steer_angle
                v *= (self._v_faster / self._v_forward) * (min_dist / self._fast_dist)
                v = max(v, self.v_slowest)
                v_left, v_right = split_throttle(angle, v)
            else:
                angle = 0
                v_left = v_right = self.v_max
        else:
            angle = steer_angle
            v_left, v_right = split_throttle(angle, v)

        
        return angle, v_left, v_right

    def ahead_clear(self, scan_unfiltered):
        Projector = LaserProjection()
        cloud = Projector.projectLaser(scan) #gets PointCloud2
        pts = pc2.read_points(cloud,skip_nans=True,field_names=("x","y","z"))
        for p in pts:
            if abs(p[1]) <= self._wheelbase_width / 2 and p[0] > 0: #is the point in the way?
                return False
        return True

if __name__=="__main__":
    
    rospy.init_node('reactive_drive')

    try:
        Driver()
    except rospy.ROSInterruptException:
        print "broken"