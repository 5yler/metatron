#!/usr/bin/env python

##
# stop
# Python script for reactive stopping based on laser scan
# 
# @author  Syler Wagner  <syler@mit.edu>
#
# @date    2016-03-05    syler   creation
##

from __future__ import division

import rospy
from std_msgs.msg import Bool   # for switching Jetson/RC mode
from sensor_msgs.msg import LaserScan   

follow_syler = False

v_forward = 5
v_slowest = 2
v_faster = 8
fast_dist = 5   #Assumes with 5m of clearance ahead we can go as fast as possible
ABS_MAX_STEERING_ANGLE = 25.0 * (math.pi / 180.0)
INCHES_TO_M = 0.0254
wheelbase_width = 23.0 * INCHES_TO_M

# RPLIDAR data constant in all LaserScan messages
angle_min = 3.14159274101
angle_max = -3.12413907051
angle_increment = -0.0174532923847
range_min = 0.15000000596
range_max = 6.0

inf = float('nan')

# helper functions
def point_ok(point):
    r, theta, intensity = point[0], point[1], point[2]
    if r < 0:
        return False
    elif intensity == 0.0: # this might not be necessary
        return False
    else:
        return True

def point_ok2(point):
    r, theta, intensity = point[0], point[1], point[2]
    if r < 0:
        return False
    elif r < range_min or r > range_max: 
        return False
    else:
        return True

def point_too_close(point):
    # this verifies a point in the filtered scan
    r, theta, intensity = point[0], point[1], point[2]
    if r < 0:
        return 0
    elif r < range_min or r > range_max: 
        return 0
    else:
        return 1

def narrow_fov(points, theta_min, theta_max):
    # return points with theta in specified range
    #narrow = [p for p in zip(points[0], points[1], points[2]) if theta_min < p[1] < theta_max]

    #TODO won't this mess up if it has enough invalid points by offsetting by their angles?
    #I would expect to need to insert some placeholder point at min or max range, or 
    #somehow otherwise indicate that their spot has unknown value, but maybe since they 
    #all have an associated theta value this is unnecessary?
    narrow = [p for p in zip(points[0], points[1], points[2]) if theta_min < p[1] < theta_max and point_ok(p)]
    return [list(n) for n in zip(*narrow)]

def generate_narrow_fov_points(ranges, intensities, theta_min=-math.pi/2, theta_max=math.pi/2):
    theta = []
    for i in xrange(360):
        if (follow_syler):
            theta.append(angle_min + i*angle_increment)
        else:
            theta.append(angle_max - i*angle_increment)
    points = [ranges, theta, intensities]
    return narrow_fov(points, theta_min, theta_max)

def polar_integrate(narrow):
    integral = 0;
    dirintegral = 0;
    for p in zip(narrow[0], narrow[1], narrow[2]):
        r = p[0]
        theta = p[1]
        if theta >= 0:
            dirintegral -= (1/r) * math.cos(theta)
        elif theta < 0:
            dirintegral += (1/r) * math.cos(theta)
        integral += (1/r) * math.cos(theta)
        #print r, theta
    #print integral, dirintegral, dirintegral/integral
    return dirintegral/integral

def steer(ranges, intensities, theta_min=-math.pi/2, theta_max=math.pi/2):
    narrow = generate_narrow_fov_points(ranges, intensities, theta_min, theta_max)
    stop_angle = polar_integrate(narrow)
    return stop_angle          #TODO did you mean to say stop_angle here?

def throttle(steer_angle):
    v = v_forward * (ABS_MAX_STEERING_ANGLE - abs(steer_angle)) / ABS_MAX_STEERING_ANGLE
    v = max(v, v_slowest) # so it doesn't stop at the extremes of turning range
    return v

def split_throttle(steer_angle, v):
    # v = control_speed
    omega = (v * math.tan(steer_angle)) / wheelbase_width
    v_left = v - (omega / wheelbase_width)   # left wheel velocity
    v_right = v + (omega / wheelbase_width)   # right wheel velocity
    return v_left, v_right

def proportional_throttle(steer_angle, ranges, intensities):
    v = throttle(steer_angle)
    points_ahead = generate_narrow_fov_points(ranges, intensities, (steer_angle - math.pi/8), (steer_angle + math.pi/8))
    min_dist = min(points_ahead)
    v *= (v_faster / v_forward) * (min_dist / fast_dist)
    v = max(v, v_slowest)
    v_left, v_right = split_throttle(steer_angle, v)
    return v_left, v_right

def sum_too_close(points):
    n_too_close = sum(point_too_close(p) for p in points)
    print " [ > ] %d points too close!" % (n_too_close)
    return n_too_close

# laser scan callback method
def callback(scan):
    ranges = scan.ranges
    intensities = scan.intensities

    points_ahead = generate_narrow_fov_points(ranges, intensities)
    n_too_close = sum_too_close(points_ahead)

    stop = Bool()

    if n_too_close > 0:
        print " [ > ] THIS NEEDS TO STOP."
        stop.data = 1
    else:
        stop_data = 0

    pub.publish(stop)


if __name__=="__main__":
    
    rospy.init_node('stop')

    # control publisher
    pub = rospy.Publisher('stop', Bool, queue_size=5)

    # scan subscriber
    rospy.Subscriber('scan_filtered', LaserScan, callback)

    rospy.spin()

